#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
Prepare dfr-browser data files from MALLET outputs.
An alternative to this script with more features can be found in the
export_browser_data function in this R package:
http://github.com/agoldst/dfrtopics

Usage:
    prepare-data check [<dir>]
        Check presence and format of data files in <dir> or PWD

    prepare-data info-stub [-o <file>]
        Write stub info.json to <file> or "info.json"

    prepare-data convert-citations ... [-o <file>] [--ids <ids>]
        Convert JSTOR DfR citations.tsv files ... into zipped metadata
        <file>: name of file to write ("meta.csv.zip" by default)
        <ids>: (optional) a file with one document ID per line. If
        supplied, these IDs are matched against the first column of the
        input metadata, and the output contains only matching documents
        (in the order given in <ids>).

    prepare-data convert-tw [-o <file>] <tw> --vocab <v> [--param <p>] [-n N]
        Write topic-word information to <file> or "tw.json"
        <tw>: CSV with topic-word matrix (headerless)
        <v>: vocabulary listing, one line per column of <tw>
        <p>: (optional) params.txt written by dfrtopics v0.2
            If this is missing, topic alpha values will be missing
        <n>: number of top words per topic (50 by default)
    prepare-data convert-keys [-o <file>] <keys>
        Write topic-word information to <file> or "tw.json"
        <keys>: CSV with topic,alpha,word,weight columns (from dfrtopics v0.1)
    prepare-data convert-dt [-o <file>] <dt>
        Write zipped document-topic information to <dt> or <dt.json.zip>
        <dt>: CSV with document-word weights (headerless).
            This ordinary matrix is converted to the required sparse format.
    prepare-data convert-state <state> [--tw <tw>] [--dt <dt>]
        Use the MALLET sampling state to write both topic words and document 
        topics.
        <state>: gzipped file from mallet train-topics --output-state or 
        dfrtopics::write_mallet_state
        <tw>: name of topic-word file to output ("tw.json" by default)
        <dt>: name of doc-topic file to output ("dt.json.zip" by default)

"""

import re
import os
import json
import zipfile
from collections import defaultdict

def check_files(d):
    fs = os.listdir(d)

    print("Checking info.json")
    if "info.json" not in fs:
        print("""
info.json not found.
Use "prepare-data info-stub" to create one.
""")
    else:
        with open(os.path.join(d, "info.json")) as f:
            try:
                json.load(f)
            except Exception as e:
                print("Unable to parse info.json as JSON. json error:\n" +
                        e.message)

    print("Checking meta.csv.zip")
    if "meta.csv.zip" in fs:
        with zf.Zipfile(os.path.join(d, "meta.csv.zip")) as z:
            with z.open(z.infolist()[0]) as f:
                meta = f.readlines()
    else:
        print("""
No meta.csv.zip found.
Use "prepare-data --convert-citations" on DfR citations.tsv files.
""")

    print("Checking topic_scaled.csv")
    if "topic_scaled.csv" not in fs:
        print("""
No topic_scaled.csv found. This file is required only for the "scaled" overview.
"""
        )

    if "tw.json" not in fs:
        print("""
No tw.json found.
Use "prepare-data --convert-tw" on a topic-word matrix CSV or
"prepare-data --convert-keys" on a CSV listing top words and weights.
""")
    else:
        with open(os.path.join(d, "tw.json")) as f:
            try:
                tw = json.load(f)
                if "alpha" not in tw:
                    raise Exception("alpha values not present")

                if "tw" not in tw:
                    raise Exception("tw field missing")

                for t in range(len(tw)):
                    if "words" not in tw[t]:
                        raise Exception("words missing for topic " + str(t + 1))
                    if "weights" not in tw[t]:
                        raise Exception("weights missing for topic " +
                                str(t + 1))
            except Exception as e:
                print("Problem with tw.json: " + e.message)

    if "dt.json.zip" not in fs:
        print("""
No dt.json.zip found.
Use "prepare-data --convert-dt" on a document-topic matrix CSV.
""")
    else:
        with zf.Zipfile(os.path.join(d, "dt.json.zip")) as z:
            with z.open(z.infolist()[0]) as f:
                try:
                    dt = json.load(f)
                    if "i" not in dt or "p" not in dt or "x" not in dt:
                        raise Exception("i, p, or x member missing")
                    if len(meta) > 0:
                        if max(dt["i"] != len(meta) - 1):
                            raise Exception("doc-topics / metadata mismatch")
                except Exception as e:
                    print("problem with doc-topics JSON: " + e.message)

def info_stub(out):
    with open(out, "w") as f:
        json.dump(
{
    "title": "",
    "meta_info": r'<h2><\/h2>',
    "VIS": { "overview_words": 15 }
})
        print("Created stub file in " + f.name)

def convert_citations(fs, matchfile, out):
    ll = []
    in_ids = defaultdict(int)
    for f in fs:
        with open(f) as meta:
            meta.readline() # header
            i = 0
            for line in meta:
                fields = ll.strip().split("\t")
                ll.append(fields[0] + "\t" + "\t".join(fields[2:9]))
                in_ids[fields[0]] = i
                i += 1

    if matchfile is not None:
        with open(matchfile) as f:
            out_ids = f.readlines()
        ll = [ll[in_ids[key]] for key in out_ids]
         
    meta_out = "\n".join(ll)
    with zf.Zipfile(out, "w") as z:
        z.writestr("meta.csv", meta_out)

    print("Wrote metadata to " + z.name)

def convert_tw(twf, out, vocabf, paramf, n):
    tw = []
    with open(vocabf) as f:
        vocab = f.readlines()

    with open(twf) as f:
        for line in f:
            weights = [int(x) for x in line.strip().split(",")]
            words = xrange(len(weights))
            words.sort(key=lambda i: -weights[i])
            tw.append(transform_topic_weights(weights, vocab))

    if paramf is None: 
        print("Warning: no parameters file, so alpha_k will be set to zero")
        alpha = [0] * len(tw)
    else:
        with open(paramf) as f:
            p = " ".join([l.strip() for l in f.readlines()])
            m = re.search(r'alpha = c\(([0-9., ]+)\)', p)
            alpha = [float(a) for a in m.group(1).split(", ")]

    write_tw(alpha, tw, out)

def transform_topic_weights(weights, vocab):
    words = xrange(len(weights))
    words.sort(key=lambda i: -weights[i])
    return({
        "words": [vocab[w] for w in words[:n]],
        "weights": [weights[w] for w in words[:n]]
    })

def write_tw(alpha, tw, out):
    twj = {
        alpha: alpha,
        tw: tw
    }
    with open(out) as f:
        json.dump(twj, f)

    print("Wrote topic-words information to " + f.name)

def convert_keys(keysf, out):
    with open(keysf) as f:
        header = f.readline()
        last_topic = 1
        for line in f:
            topic, alpha, word, weight = f.strip().split(",")
            if topic != last_topic:
                tw.append({ words: words, weights: weights })
                words = []
                weights = []
                alphas.append(alpha)
            words.append(word)
            weights.append(weight)
            last_topic = topic
        tw.append({ words: words, weights: weights})
        alphas.append(alpha)

    write_tw(alphas, tw, out)


def convert_dt(dtf, out):
    with open(dtf) as f:
        d1 = f.readline().strip()
        dt = [[int(x)] for x in d1.split(",")]
        for line in f:
            xs = line.strip().split(",")
            for t in xrange(K):
                dt[t].append(int(xs[t]))

    write_dt(transform_dt(dt), out)

def transform_dt(dt):
    K = len(dt)
    D = len(dt[0])
    p = [0]
    i = []
    x = []
    for t in xrange(K):
        for d in xrange(D):
            if d != 0:
                i.append(d)
                x.append(dt[t][d])
                p += 1
        p.append(p)

    return({ "i": i, "p": p, "x": x })

def write_dt(dtj, out):
    with zf.Zipfile(out, "w") as z:
        z.writestr("dt.json", json.dumps(dtj))

    print("Wrote sparse doc-topics to " + z.name)

def convert_state(statef, twout, dtout):
    with gzip.open(statef, 'rb') as f:
        f.readline()
        alpha = f.readline().strip().split(" ")[2:]
        beta = f.readline().strip().split(" ")[2]

        dt = []

        tw = defaultdict(lambda : defaultdict(int))
        last_doc = 0    # assume we start at doc 0
        cur_dt = defaultdict(int)
        vocab = dict()
        K = 0
        V = 0
        for line in f: 
            doc,source,pos,typeindex,word,topic = line.strip().split()
            doc = int(doc)
            typeindex = int(typeindex)
            topic = int(topic)
            if topic > K:
                K = topic
            if typeindex > V:
                V = typeindex

            if last_doc != doc:
                dt.append(cur_dt)
                cur_dt = defaultdict(int)

            curdt[topic] += 1
            tw[topic][typeindex] += 1
            if typeindex not in vocab:
                vocab[typeindex] = word

            last_doc = doc

        # final doc: after end of for loop
        if len(curdt) > 0:
            dt.append(cur_dt)
    
    write_tw([transform_topic_weights(tw[t], vocab) for t in xrange(K)],
            alpha, twout)
    write_dt(transform_dt([[d[t] for d in dt] for t in xrange(K)]), dtout)

def help():
    print(__doc__)

def key_arg(args, key):
    res = None
    try:
        i = args(key)
        res = rest[i + 1]
        del rest[i:i + 1]
    except:
        pass

    return(res)

if __name__=="__main__":
    import sys
    if len(sys.argv) == 1:
        help()
    else:
        cmd = sys.argv[1]

        if len(sys.argv) == 2:
            rest = []
        else:
            rest = sys.argv[2:]
            out = key_arg(rest, "-o")

        if cmd == "help":
            help()
        elif cmd == "check":
            if len(rest) > 0:
                check_files(rest[0])
            else:
                check_files(".")
        elif cmd == "info-stub":
            if out is None:
                info_stub("info.json")
            else:
                info_stub(out)
        elif cmd == "convert-citations":
            if out is None:
                out = "meta.csv.zip"
            matchfile = key_arg(rest, "--ids")
            convert_citations(rest, matchfile, out)
        elif cmd == "convert-tw":
            if out is None:
                out = "tw.json"
            vocabf = key_arg(rest, "--vocab")
            if vocabf is None:
                raise Exception(
                        "A vocabulary file must be supplied with --vocab")

            paramf = key_arg(rest, "--param")

            n = key_arg(rest, "-n")
            if n is None:
                n = 50
            convert_tw(rest[0], out, vocabf, paramf, n)
        elif cmd == "convert-keys":
            if out is None:
                out = "tw.json"
            convert_keys(rest[0], out)
        elif cmd == "convert-dt":
            if out is None:
                out = "dt.json.zip"
            convert_dt(rest[0], out)
        elif cmd == "convert-state":
            tw = key_arg(rest, "--tw")
            if tw is None:
                tw = "tw.json"
            dt = key_arg(rest, "--dt")
            if dt is None:
                dt = "dt.json.zip"
            convert_state(rest[0], tw, dt)
        else:
            help()

